if(type == "linear"){
model <- big_spLinReg(X = G,
y.train,
ind.train = train_index,
ind.col = ind.col,
pf.X = penalty_table$penalty,
alphas = 1,
power_scale = 1,
K = 5,
nlambda = 100,
n.abort = 10,
dfmax = 100000,
covar.train = covar.train,
pf.covar = rep(0,ncol(covar.train)),
ncores = NCORES)
}
## Run Logistic Model
if(type == "logistic"){
model <- big_spLogReg(X = G,
y.train,
ind.train = train_index,
ind.col = ind.col,
pf.X = penalty_table$penalty,
alphas = 1,
power_scale = 1,
K = 5,
nlambda = 100,
n.abort = 10,
dfmax = 100000,
covar.train = covar.train,
pf.covar = rep(0,ncol(covar.train)),
ncores = NCORES)
}
## Return model
return(model)
}
## Function to obtain beta from fitted model
obtain_beta = function(model, ind.col, map){
## Empty beta to hold covariates
beta = 0
## Loop over each of the fitted folds in CMSA
for(i in 1:length(model[[1]]) ){
beta = beta + model[[1]][[i]]$beta[1:length(ind.col)]
}
## Divide by number of folds
beta = beta/length(model[[1]])
## Add final beta to map data frame and remove the entries that are zero
beta_info = map[ind.col,]
beta_info$beta = beta
beta_info = beta_info[beta_info$beta != 0 ,]
return(beta_info)
}
fit_endoPRS = function(G, map, fam,
train_pheno, train_covar,
val_pheno, val_covar,
pheno_gwas, endo_gwas,
threshes = c(1e-2, 1e-4, 1e-6),
filter_hapmap = F, hapmap = NULL, type = NULL,
grid = NULL, NCORES = NULL,
pheno_gwas_refit, endo_gwas_refit,
save_folder = NULL){
## Check that there are no missing values
if(any(is.na(train_pheno)) |  any(is.na(val_pheno)) |
any(is.na(train_covar)) | any(is.na(val_covar)) ){
stop("Currently endoPRS cannot handle any missing values in the training or validation phenotype or covariates. Please reformat.")
}
## Check that ID's of train pheno & covar match, as well as that for validation set
if(!all.equal(train_pheno[,1:2], train_covar[,1:2])){
stop("First two columns of train pheno and train covar do not match. Please reformat.")
}
if(!all.equal(val_pheno[,1:2], val_covar[,1:2])){
stop("First two columns of val pheno and val covar do not match. Please reformat.")
}
## Check G, fam, and map input
if(nrow(G) != nrow(fam) | ncol(G) != nrow(map)){
stop("Number of rows of G not match the number of rows of fam. Please check your input.")
}
if(ncol(G) != nrow(map)){
stop("Number of columns of G not match the number of rows of map. Please check your input.")
}
## Parallelize
if(is.null(NCORES)){
NCORES = nb_cores()
}
## Create grid of weights
if(is.null(grid)){
w2 = c(1e-1, 0.5, 1, 2, 10)
w3 = c(1e-1, 0.5, 1, 2,  10)
grid = expand.grid(w2 = w2, w3 = w3)
}
#######################################################################################
###########     Part 2: Process Phenotype and Covariates    ###########################
#######################################################################################
## Obtain ID's of all individuals, training set, and validation set
geno_id = paste(fam[,1], fam[,2], sep = "_")
train_id = paste(train_pheno[,1], train_pheno[,2], sep = "_")
val_id = paste(val_pheno[,1], val_pheno[,2], sep = "_")
## Check that there is overlap between ID's
if( sum(train_id %in% geno_id) == 0 | sum(val_id %in% geno_id) == 0  ){
stop("There is no overlap between training/validation ID's and genotype ID's. Please reformat.")
}
## Obtain indices in geno id that correspond to train and validation
train_index = match(train_id, geno_id)
val_index = match(val_id, geno_id)
## Obtain y-train and y-val
y.train = c(train_pheno[,3])
y.val = c(val_pheno[,3])
## Infer type or regression if not provided
if(is.null(type)){
if(sum(!(y.train %in% c(0,1))) > 0){
type = "linear"
} else {
type = "logistic"
}
}
## Obtain Covariates for training and validation
covar.train =covar_from_df(train_covar[,-c(1,2)])
covar.val =covar_from_df(val_covar[,-c(1,2)])
#######################################################################################
######################   Part 3: Process Variant Info   ###############################
#######################################################################################
## Filter to hapmap variants
if(filter_hapmap){
if(is.null(hapmap)){
stop("Must provide hapmap data frame if selected filter_hapmap option.")
}
hapmap$unique_id1 = paste(hapmap$CHR, hapmap$SNP, hapmap$A1, hapmap$A2, sep = "_")
hapmap$unique_id2 = paste(hapmap$CHR, hapmap$SNP, hapmap$A2, hapmap$A1, sep = "_")
}
## Add unique ID to map
map$unique_id = paste(as.numeric(map$chromosome), map$marker.ID,
map$allele1, map$allele2, sep = "_")
#######################################################################################
##################      Part 4: Fit Weighted Model over grid     ######################
#######################################################################################
## Data frame to save validation results
val_results = data.frame()
## Select current thresh
for(thresh in threshes){
## Obtain SNPs associated with pheno, with endo, and with both
snps_assoc =  extract_snp_groups(pheno_gwas, endo_gwas, map, thresh, filter_hapmap, hapmap)
## Which SNPs to use
ind.col = which(map$unique_id %in% names(snps_assoc))
## Print progress
print(paste("Progress for thresh:", thresh))
## Create progress bar to track progress
pb = txtProgressBar(min = 0, max = nrow(grid), initial = 0, style = 3)
index = 0
for(iter in 1:25){
## Create table of penalties to use
penalty_table = create_penalty_table(snps_assoc, map, ind.col, w2 = grid$w2[iter], w3 = grid$w3[iter])
## Set seed for reproducibility
set.seed(1)
## Fit endoPRS weighted model
model = fit_weighted_model(G, y.train, train_index, ind.col, penalty_table, covar.train, NCORES, type)
## If save folder specified, save model
if(!is.null(save_folder)){
save_file = paste0(save_folder, "/trainingonly_model_thresh", thresh, "_w2", grid$w2[iter],"_w3", grid$w3[iter],".rds")
save(model, file = save_file)
}
## Apply to validation set
pred_val <- predict(model, G, val_index, covar.row = covar.val)
## Performance in validation set
if(type == "linear"){
val_perf = cor(pred_val, y.val)^2
}
## Performance in validation set
if(type == "logistic"){
val_perf = AUC(pred_val, y.val)
}
## Save results
res = data.frame(thresh = thresh, w2 = grid$w2[iter],
w3 = grid$w3[iter], val_res = val_perf)
val_results = rbind(val_results, res)
## Show progress in progress bar
index = index + 1
setTxtProgressBar(pb,index)
}
## Print when all models in grid done fitting for one threshold
close(pb)
print(paste("Thresh:", thresh, " is complete"))
}
## If save folder specified, save results
if(!is.null(save_folder)){
save_file = paste0(save_folder, "/trainingonly_models_results.csv")
write.csv(val_results, file = save_file)
}
#######################################################################################
###########     Part 5: Refit using combined training + validation     ################
#######################################################################################
print("Start refitting model with combined training and validation set.")
## Determine which model is best performing
best_performing_model  = val_results[which.max(val_results$val_res),]
## If alternate gwas using combined training+validation set provided, use those SNPs for refitting
if(!is.null(pheno_gwas_refit) & !is.null(endo_gwas_refit) ){
pheno_gwas = pheno_gwas_refit
endo_gwas = endo_gwas_refit
print("Using refit summary statistics")
}
## Set thresh and weights for refitting
thresh = best_performing_model$thresh
w2 = best_performing_model$w2
w3 = best_performing_model$w3
## Obtain SNPs associated with pheno, with endo, and with both
snps_assoc =  extract_snp_groups(pheno_gwas, endo_gwas, map, thresh, filter_hapmap, hapmap)
## Which SNPs to use
ind.col = which(map$unique_id %in% names(snps_assoc))
## Create table of penalties to use
penalty_table = create_penalty_table(snps_assoc, map, ind.col, w2 = w2, w3 = w3)
## Refit endoPRS weighted model
model = fit_weighted_model(G, c(y.train,y.val), c(train_index,val_index),
ind.col, penalty_table, rbind(covar.train, covar.val), NCORES, type)
## If save folder specified, save model
if(!is.null(save_folder)){
save_file = paste0(save_folder, "/combined_trainval_thresh", thresh, "_w2", w2,"_w3", w3,".rds")
save(model, file = save_file)
}
## Extract beta coefficients from fitted model
beta_info = obtain_beta(model, ind.col, map)
## Return final model and final beta
return(list(beta = beta_info, model = model))
}
fit_endoPRS(G, map, fam,
train_pheno, train_covar,
val_pheno, val_covar,
pheno_gwas, endo_gwas,
threshes = c(1e-2, 1e-4, 1e-6),
filter_hapmap = F, hapmap = NULL, type = NULL,
grid = NULL, NCORES = NULL,
pheno_gwas_refit, endo_gwas_refit,
save_folder = "../example_prs_save")
val_pheno
val_covar
val_pheno[,1:2]
head(val_covar)
head(val_pheno)
val_covar = covar[251:400,]
fit_endoPRS(G, map, fam,
train_pheno, train_covar,
val_pheno, val_covar,
pheno_gwas, endo_gwas,
threshes = c(1e-2, 1e-4, 1e-6),
filter_hapmap = F, hapmap = NULL, type = NULL,
grid = NULL, NCORES = NULL,
pheno_gwas_refit, endo_gwas_refit,
save_folder = "../example_prs_save")
## Function to change column names of GWAS and add unique id 1 and 2 column
format_gwas = function(df, map, filter_hapmap, hapmap){
## Properly format chromosome, snp, a0, a1 and p-value column for ease of use
colnames(df)[toupper(colnames(df) ) %in% c("CHROM", "CHR")] = "CHR"
colnames(df)[toupper(colnames(df) ) %in% c("ID", "RSID", "SNP")] = "SNP"
colnames(df)[toupper(colnames(df) ) %in% c("ALLELE0", "A0", "ALLELE2", "A2")] = "A0"
colnames(df)[toupper(colnames(df) ) %in% c("ALLELE1", "A1")] = "A1"
colnames(df)[toupper(colnames(df) ) %in% c("P", "PVAL")] = "P"
## Create unique ID column
unique_id1 = paste(df$CHR, df$SNP, df$A0, df$A1, sep = "_")
unique_id2 = paste(df$CHR, df$SNP, df$A1, df$A0, sep = "_")
## Add the version that matches map
df$unique_id = unique_id1
df$unique_id[unique_id2 %in% map$unique_id] = unique_id2[unique_id2 %in% map$unique_id]
## Keep only those snps that overlap with map
df = df[df$unique_id %in% map$unique_id,]
## If filter hapmap options selected, keep only those that overlap with hapmap
if(filter_hapmap){
df = df[c(df$unique_id %in% hapmap$unique_id1) | c(df$unique_id %in% hapmap$unique_id2),]
}
## Return data frame with proper column names
return(df)
}
fit_endoPRS(G, map, fam,
train_pheno, train_covar,
val_pheno, val_covar,
pheno_gwas, endo_gwas,
threshes = c(1e-2, 1e-4, 1e-6),
filter_hapmap = F, hapmap = NULL, type = NULL,
grid = NULL, NCORES = NULL,
pheno_gwas_refit, endo_gwas_refit,
save_folder = "../example_prs_save")
fit_endoPRS = function(G, map, fam,
train_pheno, train_covar,
val_pheno, val_covar,
pheno_gwas, endo_gwas,
threshes = c(1e-2, 1e-4, 1e-6),
filter_hapmap = F, hapmap = NULL, type = NULL,
grid = NULL, NCORES = NULL,
pheno_gwas_refit, endo_gwas_refit,
save_folder = NULL){
## Check that there are no missing values
if(any(is.na(train_pheno)) |  any(is.na(val_pheno)) |
any(is.na(train_covar)) | any(is.na(val_covar)) ){
stop("Currently endoPRS cannot handle any missing values in the training or validation phenotype or covariates. Please reformat.")
}
## Check that ID's of train pheno & covar match, as well as that for validation set
if(!all.equal(train_pheno[,1:2], train_covar[,1:2])){
stop("First two columns of train pheno and train covar do not match. Please reformat.")
}
if(!all.equal(val_pheno[,1:2], val_covar[,1:2])){
stop("First two columns of val pheno and val covar do not match. Please reformat.")
}
## Check G, fam, and map input
if(nrow(G) != nrow(fam) | ncol(G) != nrow(map)){
stop("Number of rows of G not match the number of rows of fam. Please check your input.")
}
if(ncol(G) != nrow(map)){
stop("Number of columns of G not match the number of rows of map. Please check your input.")
}
## Parallelize
if(is.null(NCORES)){
NCORES = nb_cores()
}
## Create grid of weights
if(is.null(grid)){
w2 = c(1e-1, 0.5, 1, 2, 10)
w3 = c(1e-1, 0.5, 1, 2,  10)
grid = expand.grid(w2 = w2, w3 = w3)
}
#######################################################################################
###########     Part 2: Process Phenotype and Covariates    ###########################
#######################################################################################
## Obtain ID's of all individuals, training set, and validation set
geno_id = paste(fam[,1], fam[,2], sep = "_")
train_id = paste(train_pheno[,1], train_pheno[,2], sep = "_")
val_id = paste(val_pheno[,1], val_pheno[,2], sep = "_")
## Check that there is overlap between ID's
if( sum(train_id %in% geno_id) == 0 | sum(val_id %in% geno_id) == 0  ){
stop("There is no overlap between training/validation ID's and genotype ID's. Please reformat.")
}
## Obtain indices in geno id that correspond to train and validation
train_index = match(train_id, geno_id)
val_index = match(val_id, geno_id)
## Obtain y-train and y-val
y.train = c(train_pheno[,3])
y.val = c(val_pheno[,3])
## Infer type or regression if not provided
if(is.null(type)){
if(sum(!(y.train %in% c(0,1))) > 0){
type = "linear"
} else {
type = "logistic"
}
}
## Obtain Covariates for training and validation
covar.train =covar_from_df(train_covar[,-c(1,2)])
covar.val =covar_from_df(val_covar[,-c(1,2)])
#######################################################################################
######################   Part 3: Process Variant Info   ###############################
#######################################################################################
## Filter to hapmap variants
if(filter_hapmap){
if(is.null(hapmap)){
stop("Must provide hapmap data frame if selected filter_hapmap option.")
}
hapmap$unique_id1 = paste(hapmap$CHR, hapmap$SNP, hapmap$A1, hapmap$A2, sep = "_")
hapmap$unique_id2 = paste(hapmap$CHR, hapmap$SNP, hapmap$A2, hapmap$A1, sep = "_")
}
## Add unique ID to map
map$unique_id = paste(as.numeric(map$chromosome), map$marker.ID,
map$allele1, map$allele2, sep = "_")
#######################################################################################
##################      Part 4: Fit Weighted Model over grid     ######################
#######################################################################################
## Data frame to save validation results
val_results = data.frame()
print(paste("Fitting grid of", nrow(grid),"models over threshes:", threshes ))
## Select current thresh
for(thresh in threshes){
## Obtain SNPs associated with pheno, with endo, and with both
snps_assoc =  extract_snp_groups(pheno_gwas, endo_gwas, map, thresh, filter_hapmap, hapmap)
## Which SNPs to use
ind.col = which(map$unique_id %in% names(snps_assoc))
## Print progress
print(paste("Progress for thresh:", thresh))
## Create progress bar to track progress
pb = txtProgressBar(min = 0, max = nrow(grid), initial = 0, style = 3)
index = 0
for(iter in 1:25){
## Create table of penalties to use
penalty_table = create_penalty_table(snps_assoc, map, ind.col, w2 = grid$w2[iter], w3 = grid$w3[iter])
## Set seed for reproducibility
set.seed(1)
## Fit endoPRS weighted model
model = fit_weighted_model(G, y.train, train_index, ind.col, penalty_table, covar.train, NCORES, type)
## If save folder specified, save model
if(!is.null(save_folder)){
save_file = paste0(save_folder, "/trainingonly_model_thresh", thresh, "_w2", grid$w2[iter],"_w3", grid$w3[iter],".rds")
save(model, file = save_file)
}
## Apply to validation set
pred_val <- predict(model, G, val_index, covar.row = covar.val)
## Performance in validation set
if(type == "linear"){
val_perf = cor(pred_val, y.val)^2
}
## Performance in validation set
if(type == "logistic"){
val_perf = AUC(pred_val, y.val)
}
## Save results
res = data.frame(thresh = thresh, w2 = grid$w2[iter],
w3 = grid$w3[iter], val_res = val_perf)
val_results = rbind(val_results, res)
## Show progress in progress bar
index = index + 1
setTxtProgressBar(pb,index)
}
## Print when all models in grid done fitting for one threshold
close(pb)
print(paste("Thresh:", thresh, " is complete"))
}
## If save folder specified, save results
if(!is.null(save_folder)){
save_file = paste0(save_folder, "/trainingonly_models_results.csv")
write.csv(val_results, file = save_file)
}
#######################################################################################
###########     Part 5: Refit using combined training + validation     ################
#######################################################################################
print("Start refitting model with combined training and validation set.")
## Determine which model is best performing
best_performing_model  = val_results[which.max(val_results$val_res),]
## If alternate gwas using combined training+validation set provided, use those SNPs for refitting
if(!is.null(pheno_gwas_refit) & !is.null(endo_gwas_refit) ){
pheno_gwas = pheno_gwas_refit
endo_gwas = endo_gwas_refit
print("Using refit summary statistics")
}
## Set thresh and weights for refitting
thresh = best_performing_model$thresh
w2 = best_performing_model$w2
w3 = best_performing_model$w3
## Obtain SNPs associated with pheno, with endo, and with both
snps_assoc =  extract_snp_groups(pheno_gwas, endo_gwas, map, thresh, filter_hapmap, hapmap)
## Which SNPs to use
ind.col = which(map$unique_id %in% names(snps_assoc))
## Create table of penalties to use
penalty_table = create_penalty_table(snps_assoc, map, ind.col, w2 = w2, w3 = w3)
## Refit endoPRS weighted model
model = fit_weighted_model(G, c(y.train,y.val), c(train_index,val_index),
ind.col, penalty_table, rbind(covar.train, covar.val), NCORES, type)
## If save folder specified, save model
if(!is.null(save_folder)){
save_file = paste0(save_folder, "/combined_trainval_thresh", thresh, "_w2", w2,"_w3", w3,".rds")
save(model, file = save_file)
}
## Extract beta coefficients from fitted model
beta_info = obtain_beta(model, ind.col, map)
## Return final model and final beta
return(list(beta = beta_info, model = model))
}
endoPRS = fit_endoPRS(G, map, fam,
train_pheno, train_covar,
val_pheno, val_covar,
pheno_gwas, endo_gwas,
threshes = c(1e-2, 1e-4, 1e-6),
filter_hapmap = F, hapmap = NULL, type = NULL,
grid = NULL, NCORES = NULL,
pheno_gwas_refit, endo_gwas_refit,
save_folder = "../example_prs_save")
model <- big_spLinReg(X = G,
y.train,
ind.train = train_index,
ind.col = ind.col,
pf.X = penalty_table$penalty,
alphas = 1,
power_scale = 1,
K = 5,
nlambda = 100,
n.abort = 10,
dfmax = 100000,
covar.train = covar.train,
pf.covar = rep(0,ncol(covar.train)),
ncores = NCORES,
warn = F)
endoPRS
endoPRS$model
endoPRS$model
covar.test
test_covar = covar[401:500,]
covar_from_df(covar.test[,-1:2])
covar_from_df(test_covar[,-1:2])
covar_from_df(test_covar[,-1:2])
test_covar[,-c(1:2)]
covar_from_df(test_covar[,-c(1:2)])
test_id = paste(test_covar$family.ID, test_covar$sample.ID, sep = "_")
test_index = match(test_id, geno_id)
geno_id = paste(fam[,1], fam[,2], sep = "_")
test_index = match(test_id, geno_id)
predict(endoPRS$model, G, test_index, covar.row = covar_from_df(test_covar[,-c(1:2)]))
test_pred = predict(endoPRS$model, G, test_index, covar.row = covar_from_df(test_covar[,-c(1:2)]))
test_pred
cor(test_pred, test_pheno$pheno)
cor(test_pred, test_pheno$pheno)^2
test_r2 = cor(test_pred, test_pheno$pheno)^2
library(usethis)
create_package("endoPRS", roxygen = T)
library(endoPRS)
library(devtools)
load_all("endoPRS")
load_all("endoPRS/")
getwd()
load_all()
load_all()
endoPRS::
endoPRS::format_gwas()
grid = data.frame(v = c(2,1))
threshes = c(0.01, 1e-4)
print(paste("Fitting grid of", nrow(grid),"models over threshes:", threshes ))
print(paste("Fitting grid of", nrow(grid),"models over threshes:", unlist(threshes) ))
paste(threshes)
print(paste("Fitting grid of", nrow(grid),"models over threshes:", paste(threshes, collapse = ", ") ))
document()
create_package("endoPRS", roxygen=T)
